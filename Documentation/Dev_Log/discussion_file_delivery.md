# Development Log Entry: Discussion on File Delivery Mechanisms

## Overview:

Yesterday's discussion focused on the architecture for delivering .ics files generated by our app. We explored two main approaches for handling this process: using WebSockets for real-time delivery and using HTTP GET requests with temporary server storage.

## WebSocket Approach:

- **Mechanism**: Files are transmitted directly to the client over a real-time WebSocket connection as soon as they are generated.
- **Pros**:
  - Real-time communication allows immediate delivery of files.
  - Eliminates the need for temporary storage on the server, as files are held in memory and not stored on disk.
- **Cons**:
  - Increases complexity due to the real-time nature of WebSockets and the need to manage potential connection issues.
  - Requires clients to support WebSockets.

## HTTP GET Approach:

The HTTP method also remind me about the older version 3.1 Azure Computer Vision API. In the code example that provided, the result is not comming back with the response of API call but need a further GET request to get the result:

```python
analysis = {}
poll = True
while (poll):
response_final = requests.get(
response.headers["Operation-Location"], headers=headers)
analysis = response_final.json()

    print(json.dumps(analysis, indent=4))

    time.sleep(1)
    if ("analyzeResult" in analysis):
        poll = False
    if ("status" in analysis and analysis['status'] == 'failed'):
        poll = False
```

- **Mechanism**: Files are temporarily stored on the server, and clients fetch them via HTTP GET requests using a unique task ID provided after POST request processing.
- **Pros**:
  - Simplifies client requirements as they only need to support standard HTTP requests.
  - Clients can fetch files at their convenience, allowing for delayed retrieval.
- **Cons**:
  - Requires implementing a mechanism for temporary file storage and managing file cleanup to ensure files are deleted after being accessed or after a set expiration time.

### Security Considerations:

- Both methods require ensuring that file access is secure and limited to the user who initiated the request. This involves authenticating access to both WebSocket connections and HTTP GET endpoints.
- Task IDs must be securely generated to prevent unauthorized access, using methods like UUIDs to ensure they are unique and non-predictable.

### Decision Points:

While both methods have their merits, the WebSocket approach aligns more closely with my goals to secure sensitive information in memory and challenge myself with new technologies. This method also reduces storage management risks and privacy concerns.
